using System;
using System.Linq;
using System.Diagnostics;
using ShellCopilot.Abstraction;

public class PowerShell
{
    private string _code { get; set; }
    private string[] _error { get; set; }
    private string[] _output { get; set; }
    private int _languageLength = "powershell\n".Length;
    private int _languageLengthBash = "bash\n".Length;

    public PowerShell(string code)
	{
        _code = code.Remove(0, _languageLength);
    }

    public PowerShell(string language, string code)
    {
        if(code.Contains("powershell"))
            _code = code.Remove(0, _languageLength);
        else if(code.Contains("bash"))
            _code = code.Remove(0, _languageLengthBash);
        else
            _code = code;
    }

    public async Task<string[]> Run()
    {
        if (!IsPowerShellOnPath())
        {
            _error = new string[2];
            _error[0] = "error";
            _error[1] = "powershell was not found on path.";
            return _error;
        }

        // write the code to a file
        string tempFile = System.IO.Path.GetTempFileName() + ".ps1";
        System.IO.File.WriteAllText(tempFile, _code);

        ProcessStartInfo start = new ProcessStartInfo();
        start.FileName = "powershell.exe";
        start.Arguments = $"-ExecutionPolicy Bypass -File \"{tempFile}\"";
        start.UseShellExecute = false; // Do not use OS shell
        start.RedirectStandardOutput = true; // Any output, generated by application will be redirected back
        start.RedirectStandardError = true; // Any error in standard output will be redirected back (for example exceptions)

        using Process process = Process.Start(start);
        await Task.Run(() => process.WaitForExit());
        _error = new string[2];
        _error[0] = "error";
        _error[1] = process.StandardError.ReadToEnd();

        //delete the file
        System.IO.File.Delete(tempFile);
        if (string.IsNullOrWhiteSpace(_error[1]))
        {
            _output = new string[2];
            _output[0] = "output";
            _output[1] = process.StandardOutput.ReadToEnd();
            return _output;
        }
        else
        {
            return _error;
        }
    }

    public static bool IsPowerShellOnPath()
    {
        var values = Environment.GetEnvironmentVariable("PATH");
        foreach (var path in values.Split(Path.PathSeparator))
        {
            var fullPath = Path.Combine(path, "powershell.exe");
            if (File.Exists(fullPath))
            {
                return true;
            }
        }
        return false;
    }
}
