using System.Diagnostics;
using Newtonsoft.Json;
using System.Text;
using System.IO;

public class PowerShell
{
    private string _code { get; set; }
    private string[] _error { get; set; }
    private string[] _output { get; set; }
    private int _languageLength = "powershell\n".Length;
    private int _languageLengthBash = "bash\n".Length;
    private int _maxOutputLength = 500;

    public PowerShell(string code)
    {
        if (code.Contains("powershell"))
            _code = code.Remove(0, _languageLength);
        else if (code.Contains("bash"))
            _code = code.Remove(0, _languageLengthBash);
        else
            _code = code;
    }

    public async Task<string[]> Run()
    {
        if (!IsPowerShellOnPath())
        {
            _error = new string[2];
            _error[0] = "error";
            _error[1] = "powershell was not found on path.";
            return _error;
        }

        // write the code to a file
        string tempFile = System.IO.Path.GetTempFileName() + ".ps1";
        System.IO.File.WriteAllText(tempFile, _code);

        ProcessStartInfo start = new ProcessStartInfo();
        start.FileName = "powershell.exe";
        start.Arguments = $"-ExecutionPolicy Bypass -File \"{tempFile}\"";
        start.UseShellExecute = false; // Do not use OS shell
        start.RedirectStandardOutput = true; // Any output, generated by application will be redirected back
        start.RedirectStandardError = true; // Any error in standard output will be redirected back (for example exceptions)
        
        using Process process = Process.Start(start);
        StreamReader streamReader = process.StandardOutput;
        StreamReader errorReader = process.StandardError;

        StringBuilder outputBuilder = new();
        StringBuilder errorBuilder = new();

        // Read the output and error streams asynchronously
        Task<string> outputTask = ReadStreamAsync(streamReader, outputBuilder);
        Task<string> errorTask = ReadStreamAsync(errorReader, errorBuilder);

        // Wait for both tasks to complete
        await Task.WhenAll(outputTask, errorTask);

        // Get the output and error strings
        string output = outputTask.Result;
        string error = errorTask.Result;

        // Clean up resources
        streamReader.Close();
        errorReader.Close();

        await process.WaitForExitAsync();
        _error = new string[2];
        _error[0] = "error";
        _error[1] = error;

        //delete the file
        System.IO.File.Delete(tempFile);

        if (process.ExitCode == 0)
        {
            if (!_error[1].Contains("error", StringComparison.CurrentCultureIgnoreCase))
            {
                _output = new string[2];
                _output[0] = "output";
                if (_error[1].Contains("warning", StringComparison.CurrentCultureIgnoreCase))
                {
                    _output[1] += _error[1];
                }
                if (output.Length > _maxOutputLength)
                {
                    output = output.Substring(0, _maxOutputLength);
                    output += "... (Output truncated)";
                }
                _output[1] = output;
                return _output;
            }
            else
            {
                return _error;
            }
        }
        else
        {
            return _error;
        }
    }

    public static bool IsPowerShellOnPath()
    {
        var values = Environment.GetEnvironmentVariable("PATH");
        foreach (var path in values.Split(Path.PathSeparator))
        {
            var fullPath = Path.Combine(path, "powershell.exe");
            if (File.Exists(fullPath))
            {
                return true;
            }
        }
        return false;
    }

    private async Task<string> ReadStreamAsync(StreamReader reader, StringBuilder builder)
    {
        string line;
        while ((line = await reader.ReadLineAsync()) != null)
        {
            builder.AppendLine(line);
        }
        return builder.ToString();
    }
}
